from pycoin.ecdsa import generator_secp256k1, sign, verify
import hashlib, bitcoin


class CryptoUtils(object):

    @staticmethod
    def calc_sha256(data):
        """
        Returns a hashed string of hexadecimal digits using sha256.
        :param data: <str> Data to hash
        :return: <str>
        """

        hash_object = hashlib.sha256(str(data).encode("utf8"))
        return hash_object.hexdigest()

    @staticmethod
    def ripemd160(data):
        """
        Returns a hashed string of hexadecimal digits using RIPEMD-160
        :param data: <str> Data to hash
        :return: <str>
        """

        hash_bytes = hashlib.new('ripemd160', data.encode("utf8"))
        return hash_bytes.hexdigest()

    @staticmethod
    def keccak_hash(data):
        """
        Returns keccak hash of data
        :param data: <str> Data to hash
        :return: <str>
        """
        hash_bytes = hashlib.sha3_256(data.encode("utf8")).digest()
        return int.from_bytes(hash_bytes, byteorder="big")

    @staticmethod
    def sign_transaction(private_key, data):
        """
        Generates a transaction signature using private key and transaction data
        :param private_key: <str> Private Key to sign with
        :param data: object/str/hash that represent the data in the transaction
        :return: <tuple<int,int>>
        """
        data_hash = CryptoUtils.keccak_hash(data)
        signature = sign(generator_secp256k1, private_key, data_hash)

        return signature

    @staticmethod
    def verify_transaction(public_key, hashed_data, signature):
        """
        Verifies a transaction based ot its signature, data and owners public key
        :param public_key: <tuple<int,int>> see: generate_public_key
        :param hashed_data: <int> that represent the data in the transaction
        :param signature: <tuple<int,int>>
        :return: <bool>
        """
        try:
            return verify(generator_secp256k1, public_key, hashed_data, signature)
        except:
            print("Provided data is invalid.")
            return False

    @staticmethod
    def generate_private_key(password):
        """
        Generates private key based on password
        :param password: <str> password for the private key
        :return: <str>
        """
        return CryptoUtils.calc_sha256(password)

    @staticmethod
    def generate_random_private_key():
        """
        Returns random private key in hex, generated by bitcoin lib
        :return: <str>
        """
        private_key = bitcoin.random_key()
        return private_key

    @staticmethod
    def generate_public_key(private_key):
        """
        Generates public key based on private key
        :param private_key: <str> Private key
        :return: <tuple<int,int>>
        """
        pk = int(private_key, 16)
        public_key = (generator_secp256k1 * pk).pair()
        return public_key

    @staticmethod
    def compress_public_key(public_key):
        """
        Compresses the public key to hex string
        :param public_key: <tuple<int,int>>
        :return: <str>
        """
        return hex(public_key[0])[2:] + str(public_key[1] % 2)

    @staticmethod
    def generate_address(public_key):
        """
        Generates network address based on public key
        :param public_key: <str>
        :return: <str>
        """
        return CryptoUtils.ripemd160(CryptoUtils.compress_public_key(public_key))

    @staticmethod
    def calc_miner_hash(block_hash, nonce):
        """
        Calculates hash taking into account block_hash+nonce
        :param block_hash: <str> Block hash
        :param nonce: <str> Nonce
        :return: <str>
        """
        return CryptoUtils.calc_sha256(str(block_hash) + str(nonce))